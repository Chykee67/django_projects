login view plan

use create_user to create user with attributes:
- username
- password
- email
- first_name
- last_name

User.objects.create_user(user attributes)

create a form that collects these details from the user during sign up -- edit SignUpForm

enable changing password using set_password:
u = User.objects.get(username="john")
u.set_password('new password')
u.save()


alternatively use authentication views and builtin forms to handle password changes

TO WATCH NEXT:
- GROUPS AND USER PERMISSIONS IN DJANGO
- ASYNCHRONOUS VIEWS IN DJANGO

HOW TO USE SESSIONS IN DJANGO (3.3.8)

TO CARRY OUT ACTIONS FOR LOGGED IN OR NOT LOGGED IN USERS USING DJANGO SESSIONS:
for regular views:
    if request.user.is_authenticated:
        .... (for logged in user)
    else:
        .... (for anonymous user)

for async views:
    user = await request.auser()

    if user.is_authenticated:
        ... (for logged in user)
    else:
        ... (for anonymous user)


How to log a user in:

from django.contrib.auth import authenticate, login, logout

def my_view(request):

    username = request.POST['username']
    password = request.POST['password']

    user = authenticate(request, username=username, password=password)

    if user is not None:
        login(request, user)
        #redirect to a success page

    else:
        #return an error message

def logout_view(request):
    logout(request)
    #redirect to a success page.

for async views use aauthenticate and alogin()

login(request, user, backend=None) -- find details of the back end.
    checkout AUTHENTICATION_BACKENDS (1092) IN settings.py


stopped at page 532.

Django class-based views

from django.views import View

class myView(Views): reference documentation at 6.3 pp 933
    ...

decorating a class in class-based view
from django.contrib.auth.decorators import login_required, permission_required

    #What are decorators?
    What effect do they have on code/view execution?
    can they be used with function-based views?
    what effect does login_required have as a decorator?
    decorating in urlconf? (409)

from django.utils.decorators import method_decorator
    how to use this

from django.views.generic import TemplateView
    how to use this?
    how is this different from Views?

stopped at page 413

remember to check out using base.html, extending base.html, {% block content %} and {% endblock %}


To implement a ListView:

from django.views.generic.list import ListView

class CartView(ListView):
    model = UserItem,
# there is a self.object_list variable created by default which contains a list of objects in this model (UserItem),
## therefore, object_list can be used in the template without providing it as a context e.g for item in object_list

    def get_context_data(self, **kwargs):
        ##used to provide other context data to template for rendering ##
        context = super().get_context_data(**kwargs)
        context['user'] = User.objects.get(first_name=user_name)

To do next:
1. password management: changing logged in user password, resetting lost password, password reset links, validating password strength
2. updating registered user information: how can I ensure to only edit certain aspects of user info, while still rendering the entire form with the current values as the initial value?
3. Caching
4. Session management: how long a user account stays logged in, conditions that automatically log you out
5. cursory glance at accepting payments
6. implementing an async view.
7. using tokens in django
8. sending emails from django web apps (Sending an email for password reset adds an extra layer of authentication, ensure to make it a part of this site)
9. restricting user access using permissions and setting default user permissions

New to-do tasks
convert all views to class-based views.
1. change all models to be like user model in login and register them in admin similarly
2. Add search function to store apps - should come last (use Q from django.db.models, __contains, __icontains and other filter tools)
3. Edit store app views to include section views, item views
4. image upload to create profile picture


Store Schema
SECTIONS
- PERSONAL CARE
- BEAUTY
- FASHION
- KIDDIES
- FOOD
- GADGETS AND APPLIANCES

SECTION CHARACTERISTICS
- TITLE
- CATEGORIES (FOREIGNKEY LINKED) - STUDY RELATIONSHIPS (ONE-TO-MANY, ONE-TO-ONE, MANY-TO-MANY) - pp. 115
- TREND_POWER - UPDATED PER ORDER PLACED FROM THIS SECTION - FOR CONSTRUCTING TRENDING SECTIONS
- SUGGESTIONS (list)- FEEDBACK FROM CUSTOMERS ON WHAT THEY WOULD LIKE ADDED OR WHAT THEY COULDN'T find (hOW TO ASSOCIATE POSTS WITH LOGGED IN USER)
- RATING FEATURE (IN FUTURE UPDATES)

models API REFERENCE - pp.1665, reference for the different django fields - 1606, create custom model fields 777
model how to guide - 109
inner class Meta - 122

making queries - 137
relationships - 115

model field attributes = {
    null
    blank
    verbose name
    choices
    primary key: if set to true, the field becomes the primary key of the model and hence must be unique for every object, altering it simply creates a new object
    help_text
    default
    unique
}

Relationships
many to one relationship 
    - use ForeignKey field e.g many cars to one manufacturer - ref 1623, 
    - 166 - accessing backwards related objects (see the cars related to a manufacturer)
    - example - 251

many to many relationships - e.g a hospital can have different doctors, a doctor can also work at multiple hospitals
    - define the relation with a manytomanyfield on only one of the related models e.g on the hospital as below:
    class MO (models.Model):
        #...

    class Hospital(models.Model):
        doctors = models.ManyToManyField(MO)

    - api ref - 1629, how to use - 245

    add extra info for a manytomany rel by creating an intermediate model (how to use - 118)
    - and using the through arg to the manytomanyfield e.g
    class Person(m...):
        #...

    class Group(m...):
        members = m.mtmf(Person, through="Membership")

    class Membership(m...):
        person = m.fk(Person)
        group = m.fk(Group)
        date_joined = m.df() #extra info
        invite_reason = m.cf()

One to One rel
    - can be implicitly implemented using inheritance (multiple inheritance study)**
    - most useful on the primary key of a model, especially if it is related to another model
    - eg using the model church to extend a place model that already has attributes like zip code, address, phone number
stopped at 121.

model attributes continued

OBJECTS
    - every model has an objects attribute that refers to the Manager (1656). the Manager is a reference to the functions that dictate the behaviour of instances of the model
    e.g: class person(models.Model):
            objects = PersonManager()
        class PersonManger(models.Model):
            def create_person(self, a, b, c):
                #instantiates a person object
                return person(a, b, c)
        methods defined in the manager have table_wide effects, affects all instances of the model
        conversely methods defined in the model have only row_wide effects, limited to the particular instance (1679)

DEFAULT MODEL METHODS
    There are default methods available to all model objects e.g save(), delete();
    it is often useful to override the behaviour of these model methods and customise them to suit your use case;

    save() - 1674; specifying fields to save - 1678, pre-delete signal/post-delete signal - 1933/4

        def save(self, **kwargs):
            if self.name == "Yoko Ono's blog":
                return # Yoko shall never have her own blog!
            else:
                super().save(**kwargs) # Call the "real" save() method.

MODELS MAY ALSO BE CREATED USING RAW SQL QUERIES - 194


MODEL INHERITANCE PATTERNS